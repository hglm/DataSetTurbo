# LIBRARY_CONFIGURATION determines whether a shared or static library will
# be built. Supported values are SHARED, STATIC and DEBUG (static with
# debugging and no optimization). The INCLUDE_DIR is the installation
# directory for library header file.
#
# The HEADER_FILE_INSTALL_DIR is the installation directory prefix for library
# header files. They will be installed in the subdirectory DataSetTurbo.
#
# SHARED_LIB_INSTALL_DIR and STATIC_LIB_INSTALL_DIR are the installation
# directories of the shared and static libraries. The target architecture
# triplet string TARGET_MACHINE, obtained from gcc -dumpmachine, may be
# prefixed with /usr/lib to generate a path like /usr/lib/x86_64-gnu-linux.
#
# PKG_CONFIG_INSTALL_DIR is the installation directory of the pkgconfig file
# datasetturbo.pc.

LIBRARY_CONFIGURATION = STATIC
HEADER_FILE_INSTALL_DIR = /usr/include
TARGET_MACHINE = `gcc -dumpmachine`
SHARED_LIB_DIR = /usr/lib/$(TARGET_MACHINE)
STATIC_LIB_DIR = /usr/lib/$(TARGET_MACHINE)
PKG_CONFIG_INSTALL_DIR = /usr/lib/$(TARGET_MACHINE)

# TARGET_CPU defines CPU to optimize for. May be left blank (for example on
# x86). It passes appropriate -mcpu and -mfpu flags to gcc. Supported values:
#
# CORTEX_A7	ARM Cortex-A7 ARMv7-A CPU cores.
# CORTEX_A15	ARM Cortex-A15 ARMv7-A CPU cores
# CORTEX_A5	ARM Cortex-A5 ARMVv7-A CPU cores.
# CORTEX_A8	ARM Cortex-A8 ARMv7-A CPU cores.
# CORTEX_A9	ARM Cortex-A9 ARMv7-A CPU cores.

TARGET_CPU =

# TARGET_SIMD defines the type of SIMD instruction set to use for vector
# math optimizations. It may be left blank fo default settings. Supported values:
#
# X86_SSE2	32-bit x86 processors with SSE2 support. SSE2 is enabled
#		by default on 64-bit x86 platforms.
# X86_SSE3	x86 processors with SSE3 support (most modern CPUs).
# ARM_NEON	ARM Cortex processors with NEON extension (currently not used).
# NONE		Disable the use of SIMD even when it is default platform feature.

TARGET_SIMD =

# PREFER_LIBC_MEMCPY defines whether the libc implementation of memcpy is always
# preferred over inline versions with unrolled and non-unrolled loops with aligned
# and non-aligned variants (may themselves may use libc memcpy for several cases).
#
# Allowed values are YES or NO. The default is NO.

PREFER_LIBC_MEMCPY = NO

# UNALIGNED_MEMORY_ACCESS defines whether the CPU can handle non-32-bit aligned
# memory access instructions. Most modern x86 and ARM CPUs can handle unaligned access
# (although usually with a performance penalty).
#
# Allowed values are YES or NO. The default is YES.

UNALIGNED_MEMORY_ACCESS = YES

